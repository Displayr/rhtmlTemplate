# Visual Regression Testing And The Internal WWW Server

## Quick Reference: how to use and extend it

* to run the visual regression suite : `gulp testVisual`
* to run the visual regression suite if the web driver binaries are already installed and `gulp serve` is already running: `gulp testVisual_s`
* to run the visual regression suite on a subset of the scenarios : `gulp testVisual --tags=<TAG>`. Only scenarios matching the tag will be run.
* to view the visual regression results: login to [https://applitools.com] and look at your new tests.
* to add a new visual regression test that does not require interaction with the widget:
    * create a new file in `theSrc/internal_www/content` using the [content_template](/theSrc/internal_www/content/content_template.html), or add an example to an existing content file IF IT FITS (dont mix concerns in your files)
    * add a `<div snapshot-name="....">` element that wraps your example(s)
* to add a new visual regression test that does require interaction with the widget:
    * create a new feature file in `bdd/features/` or add scenarios to an existing file, then follow the pattern of reusing existing steps or defining new steps
* where does the applitools key go: place it in a file called `.keys/applitools.key` no formatting, no newlines or spaces, no json, just the key.


## Objectives

There are multiple objectives served by maintaining a set of internal content for each html widget:

* **Allow visual regression testing** : We can compare the content generated by two versions of the code to determine if anything unexpected has changed. This can be done manually via inspection of the content, or automatically using a tool called [applitools](https://applitools.com).
* **Allow interaction testing** : We can write test that interact with the widget in the browser and verify certain things happen and the the final state matches a visual regression snapshot  
* **Real time feedback during dev** : This allows a workflow where I write up a config for a widget that doesn't currently support what I am trying to do, then I start writing the code to support the new feature. Every time I save my work, the widget is redrawn, so I can see in real time how my work is progressing.
 
## How the browser area is built

The internal web server is just hosting all the files in the `browser` area, which is an auto generated section of the repo. Several gulp steps work in conjunction to build the content in the `browser` directory and serve it at http://127.0.0.1:9000. The 'important' ones are described below:
 
* the `compileInternalWeb` step compiles ES6 into ES5 for the browser
* the `copy` step copies all the html and image files from `theSrc/internal_www` into the `browser` area
* the `buildContentManifest` step recursively scans the `browser/content` area and produces a manifest of all the content files in the area. This is used to build the index page that is displayed on http://127.0.0.1. Without this step the author would need to keep this list up to date by manual updates to the index.html file.
* the `connect` step starts a static content web server hosting all the files in the `browser` directory and makes them available on port 9000 of localhost (i.e., http://127.0.0.1:9000)
* the `watch` step runs constantly and monitors all the content used to build the `browser` area. Any time the content is saved, the `watch` step will rerun one of the other build steps to update the content, and then it sends a signal to the browser to force a page reload
 
## How a widget is rendered in the internal web server area

Using the content file [theSrc/internal_www/content/examples/default.html](/theSrc/internal_www/content/examples/default.html) as an example we will now go through how the widget gets drawn. Note this only applies when viewing a widget at `http://127.0.0.1:9000` (i.e., the **internal** web server). For notes on how htmlwidgets work with R, see [how the code works](./how_the_code_works.md). 

* the [renderContentPage.js](/theSrc/internal_www/js/renderContentPage.js) script is a bundled JS file that contains all the widget code, all the dependencies, and some internal web only code that performs the following tasks. The internal web only code, once the page is loaded, scans the HTML content for DOM elements with a `class="example"`. For each example, it retrieves the widget from the content of the DOM, or it does a ajax request to fetch the config file specified by he `data-config` attribute. Once it has the widget config, it then calls the widget code with the provided config, passsing the example DOM element as the root element to the widget code. This means the widget code will draw a widget inside the example DOM element.

There are some other features of [renderContentPage.js](/theSrc/internal_www/js/renderContentPage.js) that should be discussed. Each of these features is visually demonstrated here on the : Note that the [example_of_content_page_features.html](/theSrc/internal_www/content/tutorials/example_of_content_page_features.html). This page can be viewed here [http://localhost:9000/content/tutorials/example_of_content_page_features.html](http://localhost:9000/content/tutorials/example_of_content_page_features.html) if the internal server is running (i.e., `gulp serve`).
 
* The default width and height of a widget is 200 x 200. Each example can specify the width and height by using the `data-width` and `data-height` attributes.
* By default the config is hidden, but if the `data-show-config` attribute is used, then the config will be displayed above the widget. 
* By default the resize controls are hidden. The controls can be shown by adding a `data-resize-controls` attribute to the example DOM element.  
* Any DOM that has a `snapshot-name="SNAPSHOT_NAME"` attribute will cause the applitools integration to take a snapshot when the visual regression suite is run (more on this below).
    * Note that adding `snapshot-name` also changes the css `display` property to `inline-block`, which affects the layout of the content. This is done so that the width of the container is limited to the content inside, instead of the full availalbe browser width. In other words: Applitools wants a fixed box, `display: inline-block` provides this. As a result, it's better to wrap your examples with a new `<div snapshot-name="NAME">` instead of adding the `snapshot-name` attribute directly to your examples.


## The Visual Regression Testing Stack

Our Protractor + Cucumber + Applitools visual regression suite is composed of a series of technologies. 

* At the core you have [selenium](http://docs.seleniumhq.org/) which provides a programmatic way to interact with a real browser. 
* On top of that we have [webdriverJS](https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs), which is a node.js wrapper on top of selenium so that we can write selenium code in nodejs. 
* On top of that we have [protractor](http://www.protractortest.org/), which provides some angular.js specific features and some other niceities. While protractor is not strictly necessary for this project, and an alternative like webdriver.io or other could be considered, the author of the module was familiar with protractor and protractor is well packaged such that the barrier to use was minimal, thus it was chosen. Further, protractor allows the use of cucumber and applitools 
* To provide a user friendly test language, we are using the [cucumber](https://cucumber.io/) test framework so that we can write true [Given Then When / Specification By Example testing](https://martinfowler.com/bliki/GivenWhenThen.html).
* To perform snapshot baselining, we are using [applitools](http://applitools.com).

From a tester perspective, you will need to write new Cucumber scenarios in a feature file. Cucumber is made up of:
 
* `Feature files` containing `Scenarios`, each of which is one or more `steps`
* `Step Definition` files containing ... step definitions, and
* `Page Objects`, which abstract the web content under test (in our case our widget)

### Protractor + Cucumber Example 

It's easiest to use an example. Here's a trivial feature file that clicks the widget:

```
Feature: A Demo feature file
  User should be able to click on the colored squares to select them

  Scenario: User can click the blue square
    Given I am viewing "default_template_widget" with dimensions 400x400
    When I click the "blue" square
    Then the "blue" square should be selected

  Scenario: User can click the red square
    Given I am viewing "default_template_widget" with dimensions 400x400
    When I click the "red" square
    Then the "red" square should be selected
```

Some notes on the above:

* There is one `Feature` per .feature file and the feature text can be free text to descibe what is under test in the file
* There is one or more `Scenario` per file and the text to the right of the `Scenario:` is a description of the scenario.
* The rest of the lines are `Steps`. The step must start with `Given` / YOU ARE HERE ! 
* When cucumber examines the line `When I click the "blue" square`, it will look through all its step definitions for a matching step definition. If it finds one then it will execute the code. In our case there is a matching step definition in the file [widgetInteractions.steps.js](/bdd/steps/widgetInteractions.steps.js):

```
  this.When(/^I click the "([^"]+)" square$/, function (squareName) {
    return this.context.widget.selectSquare(squareName);
  });
```

This step definition extracts the string 'blue' from the `Step` in the feature file and then calls widget.selectSquare('blue'). widget in this case is a Page Object that abstracts interaction with the browser. It is defined here : '[template.page.js](/bdd/pageObjects/template.page.js)'. In that file the definition of selectSquare is :

```
  selectSquare(squareName) {
    return element(by.css(`.text.${squareName}`)).click();
  }
```

You can see that the above uses a CSS selector to identify an area in the browser and then click it! `element` is provided by protractor and is documented [here](http://www.protractortest.org/#/api). 

### Applitools Example

Again its easiest to use an example. Consider the scenario below:

```
  Scenario: User state is saved on next reload
    Given I am viewing "default_template_widget" with state "blue_square_selected" and dimensions 400x400
    Then the "default_template_widget_blue_square_selected" snapshot matches the baseline
```
 
The first `Step` tell protractor to load renderExample.html with a specific config and userState file. The second `Step` tells protractor to call applitools and take a snapshot of the widget called "default_template_widget_blue_square_selected" and compare it to the baseline version of "default_template_widget_blue_square_selected".
 
Some notes on Applitools:
 
* To see the snapshot comparison we must go to the applitools website : [http://applitools.com](http://applitools.com)
* Presently, if the snapshot does not match the protractor tests will still pass. This is a work in progress. So you need to check the website even if the tests pass !
 
## Taking all the snapshots in the content area

The visual snapshots in the content area are taken using similar steps to what is outlined above, however the process is automated such that no new test code is required when we add new content. The gulp task `buildSnapshotsFeatureFile` generates the `.tmp/snapshots.feature` file. This file contains one scenario for each content page containing a snapshot. Each scenario contains a step that cucumber interprets that causes protractor to load the page and take all the snapshots.